-- Create Enums
create type process_phase as enum ('Idea', 'Blocked', 'Flow', 'Revision', 'Finished');
create type process_visibility as enum ('public', 'private');
create type process_status as enum ('draft', 'published');
create type creative_state as enum ('Idea', 'Blocked', 'Flow', 'Revision', 'Resting');
create type feedback_type as enum ('works', 'doesnt_work', 'inspired');

-- Profiles Table (Extends Auth)
create table profiles (
  id uuid references auth.users on delete cascade not null primary key,
  updated_at timestamp with time zone,
  username text unique,
  full_name text,
  bio text,
  disciplines text[], -- Array of strings
  current_state creative_state default 'Resting',
  avatar_url text,
  
  constraint username_length check (char_length(username) >= 3)
);

-- Row Level Security for Profiles
alter table profiles enable row level security;
create policy "Public profiles are viewable by everyone." on profiles for select using (true);
create policy "Users can update own profile." on profiles for update using (auth.uid() = id);
create policy "Users can insert their own profile." on profiles for insert with check (auth.uid() = id);

-- Trigger to create profile on signup
create function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, username, full_name, avatar_url)
  values (new.id, new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'avatar_url');
  return new;
end;
$$ language plpgsql security definer;

create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();


-- Processes Table
create table processes (
  id uuid default uuid_generate_v4() primary key,
  user_id uuid references profiles(id) on delete cascade not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null,
  
  title text not null,
  description text,
  phase process_phase not null default 'Idea',
  visibility process_visibility not null default 'public',
  status process_status not null default 'draft',
  
  media_url text,
  media_type text, -- 'image' or 'audio'
  reflection_question text
);

-- RLS for Processes
alter table processes enable row level security;

-- Read: Public and Published OR Owner
create policy "Public processes are viewable by everyone." 
  on processes for select 
  using (
    (visibility = 'public' and status = 'published') 
    or 
    (auth.uid() = user_id)
  );

create policy "Users can create processes." on processes for insert with check (auth.uid() = user_id);
create policy "Users can update own processes." on processes for update using (auth.uid() = user_id);
create policy "Users can delete own processes." on processes for delete using (auth.uid() = user_id);


-- Feedback Table
create table feedback (
  id uuid default uuid_generate_v4() primary key,
  post_id uuid references processes(id) on delete cascade not null,
  user_id uuid references profiles(id) on delete cascade not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  
  type feedback_type not null,
  content text not null,
  parent_id uuid references feedback(id) on delete cascade -- For 1-level replies
);

-- RLS for Feedback
alter table feedback enable row level security;
create policy "Feedback is viewable by everyone." on feedback for select using (true);
create policy "Authenticated users can insert feedback." on feedback for insert with check (auth.role() = 'authenticated');
create policy "Users can delete own feedback." on feedback for delete using (auth.uid() = user_id);
-- No update policy for feedback to preserve 'response in the moment', or could add it.


-- AI Mentor Responses (Caching)
create table mentor_responses (
  process_id uuid references processes(id) on delete cascade not null primary key,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null,
  
  summary text,
  questions text[],
  exercise text
);

alter table mentor_responses enable row level security;
create policy "Mentor responses viewable by everyone" on mentor_responses for select using (true);
-- Only service role usually updates this, or the user causing the trigger? 
-- Let's allow authenticated users to insert/update IF they own the process (client-side trigger) OR make it server-function only.
-- For MVP, let's allow user to 'save' the response generated by API.
create policy "Users can save mentor response for own process" on mentor_responses for insert 
with check (
  exists (select 1 from processes where id = process_id and user_id = auth.uid())
);
create policy "Users can update mentor response for own process" on mentor_responses for update
using (
  exists (select 1 from processes where id = process_id and user_id = auth.uid())
);


-- Blocks Table
create table blocks (
  blocker_id uuid references profiles(id) on delete cascade not null,
  blocked_id uuid references profiles(id) on delete cascade not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  primary key (blocker_id, blocked_id)
);

alter table blocks enable row level security;
create policy "Blocks viewable by blocker" on blocks for select using (auth.uid() = blocker_id);
create policy "Users can create blocks" on blocks for insert with check (auth.uid() = blocker_id);
create policy "Users can delete blocks" on blocks for delete using (auth.uid() = blocker_id);


-- Reports Table
create table reports (
  id uuid default uuid_generate_v4() primary key,
  reporter_id uuid references profiles(id) on delete cascade not null,
  target_id uuid not null, -- Can be process_id or feedback_id or profile_id
  target_type text not null, -- 'process', 'feedback', 'profile'
  reason text not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table reports enable row level security;
create policy "Admins can view reports" on reports for select using (false); -- Lock down for now
create policy "Users can create reports" on reports for insert with check (auth.uid() = reporter_id);


-- Storage Policies (Commented out effectively, but for documentation)
-- Bucket: 'process-media'
-- Policy: Give public access to everything
-- Policy: Allow authenticated insert
-- Policy: Allow owner update/delete
